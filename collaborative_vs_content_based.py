# -*- coding: utf-8 -*-
"""collaborative vs content based.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T9We0FeSSCe862-kNVXdzzwfGIr7fWfw

Collaborative filtering
"""

import pandas as pd
import numpy as np
from scipy.sparse.linalg import svds

# Load data
ratings_df = pd.read_csv('/content/ratings.csv')
movies_df = pd.read_csv('/content/movies.csv')

# Merge dataframes on movieId
ratings_df = pd.merge(ratings_df, movies_df, on='movieId')

# Create a pivot table with user ratings
user_ratings = ratings_df.pivot_table(index='userId', columns='title', values='rating')

# Fill missing values with 0
user_ratings = user_ratings.fillna(0)

# Center ratings by subtracting the mean
mean_ratings = np.mean(user_ratings, axis=1).values
centered_ratings = user_ratings.sub(mean_ratings, axis=0).values

# Compute the SVD of the centered ratings matrix
U, sigma, Vt = svds(centered_ratings, k=50)

# Construct diagonal matrix of singular values
sigma_diag = np.diag(sigma)

# Compute predicted ratings
predicted_ratings = np.dot(np.dot(U, sigma_diag), Vt) + mean_ratings.reshape((-1, 1))

# Convert predicted ratings to a dataframe
predicted_ratings_df = pd.DataFrame(predicted_ratings, columns=user_ratings.columns, index=user_ratings.index)

# Function to get top n movie recommendations for a given user
def recommend_movies(user_id, num_recs=10):
    # Sort the predicted ratings for the user
    sorted_ratings = predicted_ratings_df.loc[user_id].sort_values(ascending=False)
    # Get the top n movie titles
    top_movie_titles = sorted_ratings.index[:num_recs]
    # Return the top n movie titles
    return top_movie_titles

rec1=recommend_movies(1, num_recs=10)
for title in rec1:
  print(title)

"""Content Beased filtering"""

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Load the movies data
movies_df = pd.read_csv('/content/movies.csv')

# Create a TF-IDF vectorizer to compute similarity between movies based on their genres
tfidf_vectorizer = TfidfVectorizer(stop_words='english')

# Compute the TF-IDF matrix for the movie genres
tfidf_matrix = tfidf_vectorizer.fit_transform(movies_df['genres'])

# Compute the pairwise cosine similarity between movies based on their genres
cosine_sim = cosine_similarity(tfidf_matrix)

# Define a function to get the top n most similar movies based on a given movie title
def get_similar_movie_titles(movie_title, num_recs=10):
    # Get the index of the movie in the cosine similarity matrix
    movie_index = movies_df.index[movies_df['title'] == movie_title][0]
    # Compute the pairwise cosine similarity between the movie and all other movies
    sim_scores = list(enumerate(cosine_sim[movie_index]))
    # Sort the list of similarity scores in descending order
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    # Get the top n most similar movie titles (excluding the movie itself)
    top_movie_titles = [movies_df.iloc[i[0]]['title'] for i in sim_scores[1:num_recs+1]]
    # Return the top n movie titles
    return top_movie_titles

movie_title = 'Indiana Jones and the Last Crusade (1989)'
rec_movie_titles = get_similar_movie_titles(movie_title)
for recs in rec_movie_titles:
  print(recs)

